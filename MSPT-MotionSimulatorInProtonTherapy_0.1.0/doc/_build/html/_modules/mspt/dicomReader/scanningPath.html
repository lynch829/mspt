

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mspt.dicomReader.scanningPath &mdash; mspt  documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="mspt  documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../index.html" class="fa fa-home"> mspt</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../mspt.html">mspt package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../mspt.html#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../mspt.html#module-mspt">Module contents</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">mspt</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>mspt.dicomReader.scanningPath</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <h1>Source code for mspt.dicomReader.scanningPath</h1><div class="highlight"><pre>
<span class="c">########################################################################</span>
<span class="c">#</span>
<span class="c"># scanningPath.py</span>
<span class="c"># </span>
<span class="c"># Created by Paul Morel, LIGM, Universite Paris-Est Marne La Vallee, France</span>
<span class="c"># paul.morel@univ-mlv.fr</span>
<span class="c"># June 2013</span>
<span class="c"># </span>
<span class="c">#</span>
<span class="c"># Copyright 2011-2014 Paul Morel, LIGM, Universite Paris-Est Marne La Vallee, France</span>
<span class="c">#</span>
<span class="c"># This file is part of MSPT- Motion Simulator in Proton Therapy.</span>
<span class="c">#</span>
<span class="c">#    MSPT- Motion Simulator in Proton Therapy is free software: you can redistribute it and/or modify</span>
<span class="c">#    it under the terms of the GNU General Public License as published by</span>
<span class="c">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c">#    (at your option) any later version.</span>
<span class="c">#</span>
<span class="c">#    MSPT- Motion Simulator in Proton Therapy is distributed in the hope that it will be useful,</span>
<span class="c">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c">#    GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c">#    You should have received a copy of the GNU General Public License</span>
<span class="c">#    along with MSPT- Motion Simulator in Proton Therapy.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">#  </span>
<span class="c">########################################################################</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">import</span> <span class="nn">dicom</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">sys</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">The module scanning path aims to manage scanning path from RP dicom files for proton-therapy. It is composed of classes:</span>

<span class="sd">    * ScanningPathMultipleBeams : Scanning path defining gantry angles: for each gantry angle a ScanningPathSingleBeam is created.</span>
<span class="sd">    * ScanningPathSingleBeam : Scanning path for 1 specific gantry angle</span>
<span class="sd">    </span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="c">#Orders for scanning path. More can be added</span>
<span class="n">scanningPath</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Random&#39;</span><span class="p">,</span> <span class="s">&#39;Regular&#39;</span><span class="p">]</span>
<span class="n">repaintingMethodSlice</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;IsolayerRepaint&#39;</span><span class="p">,</span><span class="s">&#39;ScaledRepaint&#39;</span><span class="p">,</span> <span class="s">&#39;FullWeightRepainting&#39;</span><span class="p">]</span><span class="c">#Note: &#39;FullWeightRepainting&#39;: we deliver the full weight at once instead of o maximum weight or a scaled weight.</span>
<span class="n">repaintingMethodVolume</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Volumetric&#39;</span><span class="p">,</span><span class="s">&#39;NonVolumetric&#39;</span><span class="p">]</span>

<span class="c">#Margin for compensation</span>
<span class="n">typeAdded</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">typeOrigin</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">typeOutside</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">typeIntRepaint</span> <span class="o">=</span> <span class="s">&#39;int16&#39;</span> <span class="c">#int8 :-128 to 127 </span>
<span class="n">maxRepFactor</span> <span class="o">=</span> <span class="mi">32767</span> <span class="c"># max 127 because arrays of int16: -32768 to 32767</span>



<div class="viewcode-block" id="ScanningPathMultipleBeams"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathMultipleBeams">[docs]</a><span class="k">class</span> <span class="nc">ScanningPathMultipleBeams</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Scanning path defining gantry angles: for each gantry angle a ScanningPathSingleBeam is created.</span>
<span class="sd">    </span>
<span class="sd">    :param rpData: Dicom data from pydicom for the RP dicom file.</span>
<span class="sd">    :param dictSettings: Dictionary of settings defining the behavior of the scanning path. It is explained in the class ScanningPathSingleBeam.</span>
<span class="sd">    :param typeFloat: The type of numpy float to use. It should  be either &#39;float32&#39; or &#39;float64&#39;. </span>
<span class="sd">   </span>
<span class="sd">    **__iter__( )**: </span>
<span class="sd">    </span>
<span class="sd">    Iterate through each beam and build the ScanningPathSingleBeam structure for each beams: *Ion Beam Sequence* tag in dicom documentation (i.e. each gantry angle). </span>
<span class="sd">    </span>
<span class="sd">    :returns: A tuple (the current scanning path:ScanningPathSingleBeam, the angle, the isocenter, virtual source axis distances, strAngle). strAngle = &#39;NewAngle&#39; if the gantry angle stored in the previous *Ion Beam Sequence* is different from the current gantry angle.</span>
<span class="sd">    </span>
<span class="sd">    **__len__( )**:</span>
<span class="sd">    </span>
<span class="sd">    :returns: Number of *Ion Beam Sequence*, i.e. number of beams.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rpData</span><span class="p">,</span> <span class="n">dictSettings</span><span class="p">,</span><span class="n">typeFloat</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rpData</span> <span class="o">=</span> <span class="n">rpData</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dictSettings</span> <span class="o">=</span> <span class="n">dictSettings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_typeFloat</span> <span class="o">=</span> <span class="n">typeFloat</span>
        
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterate through each beam and build the ScanninPath structure for each beams. </span>
<span class="sd">        </span>
<span class="sd">        :returns: A tuple (the current scanning path:ScanningPathSingleBeam, the angle, the isocenter, virtual source axis distances, strAngle). strAngle = &#39;NewAngle&#39; if the gantry angle stored in the previous *Ion Beam Sequence* is different from the current gantry angle.</span>

<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">prevAngle</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">indAngle</span> <span class="p">,</span> <span class="n">beam</span>  <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rpData</span><span class="o">.</span><span class="n">IonBeamSequence</span><span class="p">):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GantryAngle</span>
            <span class="n">isocenter</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">IsocenterPosition</span>
            <span class="n">vsad</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">VirtualSourceAxisDistances</span>
            <span class="n">sPath</span> <span class="o">=</span> <span class="n">ScanningPathSingleBeam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dictSettings</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_typeFloat</span><span class="p">)</span>
            <span class="n">sPath</span><span class="o">.</span><span class="n">buildScanningPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rpData</span><span class="p">,</span><span class="n">beamIdx</span> <span class="o">=</span> <span class="n">indAngle</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">prevAngle</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">prevAngle</span> <span class="o">=</span> <span class="n">angle</span>
                <span class="n">strAngle</span> <span class="o">=</span> <span class="s">&#39;NewAngle&#39;</span>
            <span class="k">elif</span> <span class="n">prevAngle</span> <span class="o">!=</span> <span class="n">angle</span><span class="p">:</span>
                <span class="n">prevAngle</span> <span class="o">=</span> <span class="n">angle</span>
                <span class="n">strAngle</span> <span class="o">=</span> <span class="s">&#39;NewAngle&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">strAngle</span> <span class="o">=</span> <span class="s">&#39;SameAngle&#39;</span>
            
            <span class="k">yield</span> <span class="p">(</span><span class="n">sPath</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span><span class="n">isocenter</span><span class="p">,</span><span class="n">vsad</span><span class="p">,</span><span class="n">strAngle</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: Number of *Ion Beam Sequence*, i.e. number of beams.</span>
<span class="sd">    </span>
<span class="sd">        &#39;&#39;&#39;</span>
    
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rpData</span><span class="o">.</span><span class="n">IonBeamSequence</span><span class="p">)</span>        

</div>
<div class="viewcode-block" id="ScanningPathSingleBeam"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam">[docs]</a><span class="k">class</span> <span class="nc">ScanningPathSingleBeam</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Scanning path defining the energies, spots positions and spots weights for each gantry angle. The key idea of this class is to represent the\</span>
<span class="sd">    scanning path of a gantry angle as a set of 3D matrices where each frame corresponds to an energy layer. Then each pixel in a frame (or each voxel \</span>
<span class="sd">    if we consider the 3D matrix entirely) represent spatially a possible scan spot position. The information contained in the set of 3D matrices will tell if the scan spot positions\</span>
<span class="sd">    are part of the treatment plan (i.e., the proton beam should irradiate what is along the pencil beam).</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    :param dictSettings: Dictionary of settings defining the behavior of the scanning path. It is explained below.</span>
<span class="sd">    :param typeFloat: The type of numpy float to use. It should  be either &#39;float32&#39; or &#39;float64&#39;. </span>
<span class="sd">    </span>
<span class="sd">    The set of 3D matrices representing a scanning path is composed of:</span>
<span class="sd">        </span>
<span class="sd">        * 1 matrix storing the **X positions** of the scan spots. If a voxel (frame0,row0,column0) has a value of 0, it means that this voxel does not \</span>
<span class="sd">        belong to the treatment plan. If the value is non-null then it is part of the plan. Spatially, moving of 1 frame means changing energy, and moving of\</span>
<span class="sd">        1 row (resp. column) means moving the pencil beam of row_spacing mm (resp. column_spacing mm). The spacing is the smallest y (resp. x) difference between\</span>
<span class="sd">        two consecutive scan spots.</span>
<span class="sd">        * 1 matrix storing the **Y positions** of the scan spots. Similar to the previous matrix.</span>
<span class="sd">        * 1 matrix storing the **planned weight** for each spot position. The weight is set to 0 for scan spots that do not belong to the plan.</span>
<span class="sd">        * 1 matrix storing the **planned weight for each spot position at the time of the delivery**. Therefore the weight is set to 0 for scan spots that do not \</span>
<span class="sd">        belong to the plan or that have already been delivered. This matrix is updated during the delivery.</span>
<span class="sd">        * 1 matrix storing the **type of scan spot position**. If the type is &#39;0&#39;, the pencil beam will never stop at this position. If the &#39;type&#39; is &#39;1&#39;, it means\</span>
<span class="sd">        that the pencil beam will stop at this position and that this spot is part of the treatment plan. If the &#39;type&#39; is &#39;2&#39;, it means that under certain circumstances\</span>
<span class="sd">        (i.e. if &#39;AddMapMargins&#39; if dictSettings is True - see below) the pencil beam will go by this position, but the weight affected to it is null. This \</span>
<span class="sd">        allow to have more spot positions. This is especially used if the delivery is compensated.</span>
<span class="sd">        * 1 matrix storing the **number of repainting** of each scan spot: &#39;0&#39; if the pencil beam will not go by a specific scan position, a positive integer otherwise.\</span>
<span class="sd">        This matrix is updated during the delivery.</span>
<span class="sd">    </span>
<span class="sd">   </span>
<span class="sd">    **dictSettings**:</span>
<span class="sd">    </span>
<span class="sd">    dictSettings is a dictionary with mandatory keys and optional keys that depend on the desired behavior of the scanning path. Keys and values are defined here:</span>
<span class="sd">    </span>
<span class="sd">        * **&#39;TypeScanning&#39;** (mandatory):  values:  &#39;Random&#39; or  &#39;Regular&#39;.  &#39;Random&#39;: the spot positions are chosen randomly both for the energy and the position. &#39;Regular&#39;: the spot positions are chosen from the highest energy to the smallest and in the order provided by the RP dicom file.</span>
<span class="sd">        * **&#39;Repainting&#39;** (mandatory):  values:  True, if one wants to deliver the treatment plan using the repainting technique, False otherwise.</span>
<span class="sd">        * **&#39;SliceRepaint&#39;** (mandatory if &#39;Repainting&#39; is True): method to use to repaint an energy layer.  values: [&#39;IsolayerRepaint&#39;,&#39;ScaledRepaint&#39;, &#39;FullWeightRepainting&#39;] :</span>
<span class="sd">                * *&#39;IsolayerRepaint&#39;*: a maximum weight will be calculated as the minimum weight of all the weight defined in the treatment plan.   </span>
<span class="sd">                * *&#39;ScaledRepaint&#39;* : a fixed number of repaintings is defined.</span>
<span class="sd">                * *&#39;FullWeightRepainting&#39;* : used for compensation: we deliver the full weight instead of a maximum weight or a scaled weight. If not used with the compensation it is equivalent to no repainting. It can also bee seen as a scaled repainting of repainting factor 1.</span>
<span class="sd">        * **&#39;VolumeRepainting&#39;** (mandatory if &#39;Repainting&#39; is True): method used to repaint the entire volume. Values: [&#39;Volumetric&#39;,&#39;NonVolumetric&#39;]:</span>
<span class="sd">                * *&#39;Volumetric&#39;*: Scan energy layer by energy layer to paint the volume a first time then repaint the volume layer by layer and so on.</span>
<span class="sd">                * *&#39;NonVolumetric&#39;*: Repaint each layer the number of time desired before moving to the next energy layer.</span>
<span class="sd">        * **&#39;UnlimitedRescan&#39;** (mandatory if &#39;ScaledRepaint&#39; or  &#39;FullWeightRepainting&#39; and if &#39;RepaintFactor&#39; is not present): values: \</span>
<span class="sd">        True if one wants to allow an unlimited number of repainting, i.e. not controlled by an maximum number of repaintings.\</span>
<span class="sd">        However, to avoid infinite loops, a maximum number of repainting is however set to 32767 (max value of an int16). \</span>
<span class="sd">        One must note that if &#39;RepaintFactor&#39; is present, the value of &#39;UnlimitedRescan&#39; will have a higher priority.</span>
<span class="sd">        * **&#39;RepaintFactor&#39;** (mandatory if &#39;ScaledRepaint&#39; or  &#39;FullWeightRepainting&#39; and if &#39;UnlimitedRescan&#39; is not present): \</span>
<span class="sd">        value: integer value (1-127) defining the number of repaintings desired.\</span>
<span class="sd">        One must note that if &#39;UnlimitedRescan&#39; is present, the value of &#39;UnlimitedRescan&#39; will have a higher priority.</span>
<span class="sd">        * **&#39;AddMapMargins&#39;** (optional): One has to note that we call &quot;map&quot; the set of spot positions within an energy layer (name used in Dicom documentation Scan Spot Position Map).\</span>
<span class="sd">        Values: True if one wants to add &quot;margins&quot; (i.e. spot positions of weight 0) around the native maps defined in the energy layers of the RP dicom file. This option is more dedicated to the compensation technique. \</span>
<span class="sd">        False (default value): if one do not want to add margins to the map. The margin is created using a maximum thickness of expansion (defined by &#39;Margin Params&#39;) and by performing a dilation. Each spot of the scanning path is viewed as\</span>
<span class="sd">        a voxel in a 3D binary matrix, the dilation is applied to the volume represented by these non-null voxels.</span>
<span class="sd">        * **&#39;MarginParams&#39;** (mandatory if &#39;AddMapMargins&#39; is True): value: an iterable of positive real values. It represents the width of the margin in mm along the [x,y,z] axis in the IEC Gantry coordinate system (i.e. coordinate system in which spot positions are defined).</span>
<span class="sd">        * **&#39;3DMargins&#39;** (mandatory if &#39;AddMapMargins&#39; is True): values: True if the the map is also extended along the z axis of the IEC gantry coordinate system. In other words, this adds energy layers in addition to spot positions. \</span>
<span class="sd">        False, if one do not want to extend the map in 3D. In this case the 3rd element of &#39;MarginParams&#39; is discarded.</span>
<span class="sd">        * **&#39;UpdateMargins&#39;** (mandatory if &#39;AddMapMargins&#39; is True): controls whether the map with the margins are updated between repaintings. From one repainting to another the map of an energy layer can change depending on the spots that have been entirely deliverd. \</span>
<span class="sd">        Values: True or False.</span>
<span class="sd">        * **&#39;FindStartPos&#39;** (optional): True or False. It is used for the compensation. If set to True, it will find the first spot, of an energy layer, that could be delivered in a map for a given motion vector.</span>
<span class="sd">        </span>
<span class="sd">     </span>
<span class="sd">     **__len__( )**: </span>
<span class="sd">     </span>
<span class="sd">     :returns: The number of energy layers.</span>
<span class="sd">     </span>
<span class="sd">     **__iter__( )**:</span>
<span class="sd">     </span>
<span class="sd">     Iterates through the spots following the order defined in dictSettings.       </span>
<span class="sd">     </span>
<span class="sd">     :returns: A tuple:</span>
<span class="sd">     </span>
<span class="sd">        * index 0: spot weight</span>
<span class="sd">        * index 1: spot in the 3D matrices : frame, row, column </span>
<span class="sd">        * index 2: x position</span>
<span class="sd">        * index 3: y position</span>
<span class="sd">        * index 4: energy</span>
<span class="sd">        * index 5: list of 2 elements : spot size along x and along y </span>
<span class="sd">        * index 6: &#39;NewEnergy&#39; if the energy is changing or &#39;SameEnergy&#39; otherwise </span>
<span class="sd">        * index 7: spot type = 1 (native spot) or 2 (spot from added margin) </span>
<span class="sd">        * index 8: repainting index</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictSettings</span><span class="p">,</span><span class="n">typeFloat</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_typeFloat</span> <span class="o">=</span> <span class="n">typeFloat</span>
        
        <span class="c">#Process settings in dictSettings:</span>
        <span class="k">if</span> <span class="s">&quot;TypeScanning&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No TypeScanning key in scanning path settings&quot;</span><span class="p">)</span>
        <span class="n">typeSet</span> <span class="o">=</span>  <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;TypeScanning&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">typeSet</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scanningPath</span><span class="p">:</span>
            <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Unknown type in scanning path settings: </span><span class="si">%s</span><span class="s"> &quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">typeSet</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
    
        <span class="c">#Initialize scanning path variable for non random delivery</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scanPath</span> <span class="o">=</span> <span class="n">typeSet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scanPath</span> <span class="o">!=</span> <span class="n">scanningPath</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c"># : random , regular</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">=</span> <span class="bp">None</span> <span class="c">#store the index of the current energy slice</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span> <span class="o">=</span> <span class="bp">None</span> <span class="c">#store the list of the spots of the current energy slice. The order in the list defines to order that will be</span>
                                            <span class="c">#used when iterating through the list of spots.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># store the index of the next spot in the current energy slice</span>
            
        
        <span class="c">#Verify that the key &quot;Repainting&quot; is present and that is a boolean.</span>
        <span class="k">if</span> <span class="s">&quot;Repainting&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No Repainting key in scanning path settings&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;Repainting&quot;</span><span class="p">],</span><span class="nb">bool</span><span class="p">):</span>
            <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Value for Repainting key in scanning path should be a bool not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;Repainting&quot;</span><span class="p">]))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
        
        
        <span class="c"># If the user wants to use the repainting</span>
        <span class="k">if</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;Repainting&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="c">#Slice repainting</span>
            <span class="k">if</span> <span class="s">&quot;SliceRepaint&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No SliceRepaint key in scanning path settings&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;SliceRepaint&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">repaintingMethodSlice</span><span class="p">:</span>
                <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Value for SliceRepaint is not in </span><span class="si">%s</span><span class="s"> : value: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">repaintingMethodSlice</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;SliceRepaint&quot;</span><span class="p">]))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
            
            <span class="c">#Method slice repainting</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;SliceRepaint&quot;</span><span class="p">]</span>
                
                <span class="c">#&#39;IsolayerRepaint&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c">#[&#39;IsolayerRepaint&#39;,&#39;ScaledRepaint&#39;, &#39;FullWeightRepainting&#39;]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_maxWeight</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="c">#Method Volume repainting</span>
                <span class="k">if</span> <span class="s">&quot;VolumeRepainting&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;VolumeRepainting is not in the scanning path settings&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;VolumeRepainting&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">repaintingMethodVolume</span><span class="p">:</span>
                    <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Value for VolumeRepainting is not in </span><span class="si">%s</span><span class="s"> : value: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">repaintingMethodVolume</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;VolumeRepainting&quot;</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodVolume</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;VolumeRepainting&quot;</span><span class="p">]</span>
                    
                    <span class="c">#&#39;ScaledRepaint&#39; or  &#39;FullWeightRepainting&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                
                <span class="k">if</span> <span class="s">&quot;UnlimitedRescan&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="s">&quot;RepaintFactor&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;UnlimitedReapint and RepaintFactor are not in the scanning path settings.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;RepaintFactor&quot;</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span>
                            <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;RepaintFactor must be an integer, not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;RepaintFactor&quot;</span><span class="p">]))</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;RepaintFactor&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;UnlimitedRescan&quot;</span><span class="p">],</span><span class="nb">bool</span><span class="p">):</span>
                        <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;UnlimitedRescan in scanning path setting must be a bool, not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;UnlimitedRescan&quot;</span><span class="p">]))</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;UnlimitedRescan&quot;</span><span class="p">]:</span>
                    <span class="c">#if infiniteRepaintFactor:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span> <span class="o">=</span> <span class="n">maxRepFactor</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s">&quot;RepaintFactor&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;RepaintFactor is not in the scanning path settings.&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;RepaintFactor&quot;</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span>
                                <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;RepaintFactor must be an integer, not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;RepaintFactor&quot;</span><span class="p">]))</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;RepaintFactor&quot;</span><span class="p">]</span>
                            
                    <span class="c">#verify volume repainting  for &#39;ScaledRepaint&#39; or  &#39;FullWeightRepainting&#39;</span>
                <span class="k">if</span> <span class="s">&quot;VolumeRepainting&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;VolumeRepainting is not in the scanning path settings&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;VolumeRepainting&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">repaintingMethodVolume</span><span class="p">:</span>
                    <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Value for VolumeRepainting is not in </span><span class="si">%s</span><span class="s"> : value: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">repaintingMethodVolume</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;VolumeRepainting&quot;</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodVolume</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;VolumeRepainting&quot;</span><span class="p">]</span>
                
            <span class="c">######## End if  &#39;IsolayerRepaint&#39; else ( &#39;ScaledRepaint&#39; or  &#39;FullWeightRepainting&#39;)</span>
            
        <span class="k">else</span><span class="p">:</span> <span class="c"># If the user don&#39;t want to use the repainting</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">=</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodVolume</span> <span class="o">=</span> <span class="n">repaintingMethodVolume</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="s">&quot;AddMapMargins&quot;</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c">#raise ValueError(&quot;AddMapMargins is not in the scanning path settings&quot;)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;AddMapMargins&quot;</span><span class="p">],</span><span class="nb">bool</span><span class="p">):</span>
                <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;AddMapMargins in scanning path setting must be a bool, not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;AddMapMargins&quot;</span><span class="p">]))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;AddMapMargins&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="s">&quot;MarginParams&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> 
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;MarginParams is not in the scanning path settings&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">],</span><span class="nb">list</span><span class="p">):</span>
                    <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;MarginParams in scanning path setting must be a list, not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                
                <span class="n">checkList</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">item</span> <span class="o">==</span> <span class="bp">True</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">checkList</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;All elements in MarginParams should be numbers...&quot;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="s">&quot;3DMargins&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;3DMargins is not in the scanning path settings&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;3DMargins&quot;</span><span class="p">],</span><span class="nb">bool</span><span class="p">):</span>
                    <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;3DMargins in scanning path setting must be a bool, not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;3DMargins&quot;</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_map3DMargin</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;3DMargins&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map3DMargin</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;MarginParams should contain 3 parameters since 3DMargins is True. It contains </span><span class="si">%i</span><span class="s"> parameters.&quot;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">])</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_marginParams</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">]</span><span class="c"># extension in mm for [x , y, z] -&gt; this means for ex. add a margin of (x mm) at the right of the map and (x mm) at the left of the map.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;MarginParams should contain 2 or 3 parameters. It contains </span><span class="si">%i</span><span class="s"> parameters.&quot;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">])</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_marginParams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_marginParams</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;MarginParams&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="c"># extension in mm for [x , y, z] -&gt; this means for ex. add a margin of (x mm) at the right of the map and (x mm) at the left of the map.</span>
                <span class="k">if</span> <span class="s">&quot;UpdateMargins&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;UpdateMargins is not in the scanning path settings&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;UpdateMargins&quot;</span><span class="p">],</span><span class="nb">bool</span><span class="p">):</span>
                    <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;UpdateMargins in scanning path setting must be a bool, not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;3DMargins&quot;</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_UpdateDMargin</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;UpdateMargins&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span> <span class="o">=</span>  <span class="bp">False</span>
            
        <span class="k">if</span> <span class="s">&quot;FindStartPos&quot;</span> <span class="ow">in</span> <span class="n">dictSettings</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;FindStartPos&quot;</span><span class="p">],</span><span class="nb">bool</span><span class="p">):</span>
                    <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;FindStartPos in scanning path setting must be a bool, not a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;FindStartPos&quot;</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_findStartPos</span> <span class="o">=</span> <span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;FindStartPos&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_findStartPos</span> <span class="o">=</span> <span class="bp">False</span>
                
            <span class="c">#Arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialPath</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span> <span class="o">=</span> <span class="bp">None</span>
        
            <span class="c">#Variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gantryAngle</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listSpotSize</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="k">print</span> <span class="s">&quot;--------------------------------------------&quot;</span>
        <span class="k">print</span> <span class="s">&quot;Scanning delivery settings:&quot;</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Type Scanning: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scanPath</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Repainting: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">dictSettings</span><span class="p">[</span><span class="s">&quot;Repainting&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_repaintingMethodSlice&#39;</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Slice repaint: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_repaintingMethodVolume&#39;</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Volume repaint: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodVolume</span><span class="p">)</span>
            <span class="c">#self._repaintFactor</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_repaintFactor&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span> <span class="o">==</span> <span class="n">maxRepFactor</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Repainting factor: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="s">&#39;Unlimited&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Repainting factor: </span><span class="si">%i</span><span class="s">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Margins added: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Margin parameters (mm): </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_marginParams</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t\t</span><span class="s">Find a good starting position: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_findStartPos</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;--------------------------------------------&quot;</span>


   
            

<div class="viewcode-block" id="ScanningPathSingleBeam.getRepaintingFactor"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getRepaintingFactor">[docs]</a>    <span class="k">def</span> <span class="nf">getRepaintingFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: If a repainting factor exists, it returns it, otherwise it returns None.</span>
<span class="sd">    </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_repaintFactor&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span>
        <span class="k">return</span> <span class="bp">None</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ScanningPathSingleBeam.repaintingMethodSlice"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.repaintingMethodSlice">[docs]</a>    <span class="k">def</span> <span class="nf">repaintingMethodSlice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: The energy layer repainting method : &#39;IsolayerRepaint&#39;,&#39;ScaledRepaint&#39; or &#39;FullWeightRepainting&#39;</span>
<span class="sd">    </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span>
        </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ScanningPathSingleBeam.repaintingMethodVolume"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.repaintingMethodVolume">[docs]</a>    <span class="k">def</span> <span class="nf">repaintingMethodVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: The volume repainting method : &#39;Volumetric&#39; or &#39;NonVolumetric&#39;</span>
<span class="sd">    </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodVolume</span>
        </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ScanningPathSingleBeam.arrayX"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.arrayX">[docs]</a>    <span class="k">def</span> <span class="nf">arrayX</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: 3D numpy array containing X coordinate of scan spot positions. Each frame of the matrix correspond to an energy layer. \</span>
<span class="sd">        X value is set to 0 in the matrix if the spot is not a scan spot position.</span>
<span class="sd">        &#39;&#39;&#39;</span>    
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ScanningPathSingleBeam.arrayY"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.arrayY">[docs]</a>    <span class="k">def</span> <span class="nf">arrayY</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: 3D numpy array containing Y coordinate of scan spot positions. Each frame of the matrix correspond to an energy layer. \</span>
<span class="sd">        Y value is set to 0 in the matrix if the spot is not a scan spot position.</span>
<span class="sd">        &#39;&#39;&#39;</span>  
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span>
        </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ScanningPathSingleBeam.arraySpots"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.arraySpots">[docs]</a>    <span class="k">def</span> <span class="nf">arraySpots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: 3D numpy array containing the planned weights of scan spot positions. Each frame of the matrix correspond to an energy layer. \</span>
<span class="sd">        Weight value is set to 0 in the matrix if the spot is not a scan spot position or if it has already been delivered.</span>
<span class="sd">        &#39;&#39;&#39;</span>  
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="ScanningPathSingleBeam.listEnergies"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.listEnergies">[docs]</a>    <span class="k">def</span> <span class="nf">listEnergies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: A list of energies used. The order is from higher energy to lowest.</span>
<span class="sd">        &#39;&#39;&#39;</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span>

    </div>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :returns: Number of energy layers.</span>
<span class="sd">        &#39;&#39;&#39;</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span>
        

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Iterates through the spots following the order defined in dictSettings. </span>
<span class="sd">        :returns: A tuple: \</span>
<span class="sd">        ( weight spot ,index spot in the 3D matrices : frame, row, column , x positions,y positions,energy,spot size along x and along y , \</span>
<span class="sd">        strEnergy : &#39;NewEnergy&#39; if the energy is changing or &#39;SameEnergy&#39; otherwise ,typeSpot = 1 (native spot) or 2 (spot from added margin) , repainting index)</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">prevEnergy</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scanPath</span> <span class="o">==</span> <span class="s">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">indexArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indexArray</span><span class="p">)</span>
            <span class="n">arrayShape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexArray</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; New Spot &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">arrayShape</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prevEnergy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">prevEnergy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">strEnergy</span> <span class="o">=</span> <span class="s">&#39;NewEnergy&#39;</span>
                <span class="k">elif</span> <span class="n">prevEnergy</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">prevEnergy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">strEnergy</span> <span class="o">=</span> <span class="s">&#39;NewEnergy&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">strEnergy</span> <span class="o">=</span> <span class="s">&#39;SameEnergy&#39;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
                    <span class="n">typeSpot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">typeSpot</span> <span class="o">=</span> <span class="n">typeOrigin</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_repaintingIndex&#39;</span> <span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">repaintIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">repaintIndex</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">yield</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="p">,</span><span class="n">ind</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">_listSpotSize</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">,</span><span class="n">strEnergy</span><span class="p">,</span><span class="n">typeSpot</span> <span class="p">,</span> <span class="n">repaintIndex</span><span class="p">)</span>
                
                
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scanPath</span> <span class="o">==</span> <span class="s">&#39;Regular&#39;</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Regular delivery&quot;</span>
            <span class="n">arrayShape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">it</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nextSpotIndex</span><span class="p">()</span>
            
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; New Spot &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>
                <span class="k">print</span> <span class="s">&quot;Spot idx. in Scan Path: </span><span class="si">%i</span><span class="s"> , (f,r,c):</span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">prevEnergy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">prevEnergy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">strEnergy</span> <span class="o">=</span> <span class="s">&#39;NewEnergy&#39;</span>
                <span class="k">elif</span> <span class="n">prevEnergy</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">prevEnergy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">strEnergy</span> <span class="o">=</span> <span class="s">&#39;NewEnergy&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">strEnergy</span> <span class="o">=</span> <span class="s">&#39;SameEnergy&#39;</span>
                <span class="n">dataSpot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildDataSpotToReturn</span><span class="p">(</span><span class="n">ind</span> <span class="p">,</span> <span class="n">strEnergy</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">dataSpot</span>

                        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown spotOrder in scanningPath&#39;</span><span class="p">)</span>






        



<div class="viewcode-block" id="ScanningPathSingleBeam.nextSpotIndex"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.nextSpotIndex">[docs]</a>    <span class="k">def</span> <span class="nf">nextSpotIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        </span>
<span class="sd">        :yields: The next spot positions index (frame, rows, column in the 3D matrices representing the scanning path) if &#39;TypeScanning&#39; (in &#39;dictSettings&#39;) \</span>
<span class="sd">        is not &#39;random&#39;. This method is called from __iter__()</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
    
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodVolume</span> <span class="o">==</span> <span class="n">repaintingMethodVolume</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c">#&#39;Non Volumetric&#39;</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">repaintingNonVolOrder</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">ind</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodVolume</span> <span class="o">==</span> <span class="n">repaintingMethodVolume</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c">#&#39;Volumetric&#39;</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">repaintingVolOrder</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">ind</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Wrong repaintingMethodVolume: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodVolume</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
    
    
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.setNextSpotIndex"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.setNextSpotIndex">[docs]</a>    <span class="k">def</span> <span class="nf">setNextSpotIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind3D</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Set the next spot index : frame, rows, column in the 3D matrices representing the scanning path</span>
<span class="sd">        </span>
<span class="sd">        :param ind3D: list of 3 elements : [frame,row,column]</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span> <span class="o">=</span>  <span class="p">[</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    
</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.buildSliceScanningOrder"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.buildSliceScanningOrder">[docs]</a>    <span class="k">def</span> <span class="nf">buildSliceScanningOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Build the spot scanning order within the current energy slice. It sets the class attribute &#39;self._sliceScanningOrder&#39;.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSliceOrderFromPlan</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">list</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">list</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">]</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSliceOrderFromPlan</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c">#If nothing left to deliver initialize the variable and the iterations will stop</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">list</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">list</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_UpdateDMargin</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int8&#39;</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extendMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">updateXYAndNbRepatings</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>

                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">typeOrigin</span><span class="p">)</span> <span class="o">|</span> \
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">typeAdded</span><span class="p">))</span> <span class="o">&amp;</span> \
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">list</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">list</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">]</span>
        

    <span class="c">## Repainting</span></div>
<div class="viewcode-block" id="ScanningPathSingleBeam.repaintingNonVolOrder"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.repaintingNonVolOrder">[docs]</a>    <span class="k">def</span> <span class="nf">repaintingNonVolOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Generator for the non volumetric repainting order.\</span>
<span class="sd">        Order: slice by slice : repaint a slice before going to the next slice. \</span>
<span class="sd">        Higher energy to lowest energy.</span>
<span class="sd">        </span>
<span class="sd">        :yields: The next spot index (frame,row,column). This method is called by nextSpotIndex()</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">print</span> <span class="s">&quot;Non Volumetric repainting&quot;</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buildSliceScanningOrder</span><span class="p">()</span>
            <span class="k">print</span> <span class="s">&quot;Nb spots in scanning path: </span><span class="si">%i</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;Index in scanning path: </span><span class="si">%i</span><span class="s">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">setNextSpotIndex</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span><span class="p">]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">buildSliceScanningOrder</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">print</span> <span class="s">&quot;------------------Starting new repainting---------------&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">setNextSpotIndex</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span><span class="p">]])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
                        </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.repaintingVolOrder"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.repaintingVolOrder">[docs]</a>    <span class="k">def</span> <span class="nf">repaintingVolOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Generator for the volumetric repainting order.</span>
<span class="sd">        </span>
<span class="sd">        :yields: The next spot index (frame,row,column). This method is called by nextSpotIndex()</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">=</span> <span class="mi">0</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buildSliceScanningOrder</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;------------------Starting new repainting---------------&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">setNextSpotIndex</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span><span class="p">]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
                        
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.getWeightForSpotInd"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getWeightForSpotInd">[docs]</a>    <span class="k">def</span> <span class="nf">getWeightForSpotInd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ind3D</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param ind3D: 3D indices: (frame, row, column) defined in the 3D matrices representing the scanning path.</span>
<span class="sd">        </span>
<span class="sd">        :returns: The weight to be delivered of the spot stored at (frame, row, column) of the weight matrix. It takes into account the repainting index.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">repaintFactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">repaintFactor</span> <span class="o">&gt;</span>  <span class="mi">1</span> <span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxWeight</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">weight</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">repaintFactor</span> <span class="o">&gt;=</span>  <span class="mi">1</span> <span class="p">:</span>
                <span class="k">return</span> <span class="n">weight</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">repaintFactor</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">weight</span>
                
                </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.getPlannedWeightForSpotInd"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getPlannedWeightForSpotInd">[docs]</a>    <span class="k">def</span> <span class="nf">getPlannedWeightForSpotInd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ind3D</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param ind3D: 3D indices: (frame, row, column) defined in the 3D matrices representing the scanning path.</span>
<span class="sd">        </span>
<span class="sd">        :returns: The planned weight of the spot stored at (frame, row, column) of the weight matrix.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialPath</span><span class="p">[</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind3D</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">weight</span>

        
        
        </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.updateSpot"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.updateSpot">[docs]</a>    <span class="k">def</span> <span class="nf">updateSpot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">decrRepaint</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Update the weight of a spot located in the 3D array at &#39;indices&#39;:</span>
<span class="sd">        remove &#39;weight&#39; from the value contained in the matrix storing the updated spot weights.</span>
<span class="sd">        </span>
<span class="sd">        :param indices: 3D indices: (frame, row, column) defined in the 3D matrices representing the scanning path.</span>
<span class="sd">        :param weight: weight to be removed from the weight matrix</span>
<span class="sd">        :param decrRepaint: True / False : True if one wants to decrement the repainting factor of the current spot, False otherwise.    </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">weight</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">print</span>  <span class="s">&quot;Warning Hot Spot: dose deposited higher than planned&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>  <span class="o">&lt;=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>  <span class="o">=</span> <span class="mi">0</span>
           
        <span class="k">print</span> <span class="s">&quot;Spot updated: </span><span class="si">%s</span><span class="s"> / new weight: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>  <span class="p">)),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]])))</span>
        <span class="k">if</span> <span class="n">decrRepaint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decrementRepaint</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        
        </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.decrementRepaint"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.decrementRepaint">[docs]</a>    <span class="k">def</span> <span class="nf">decrementRepaint</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Decrement the repainting index of the spot stored at &#39;indices&#39; in the matrix storing the repainting factor of each spot.</span>
<span class="sd">        </span>
<span class="sd">        param indices: 3D indices: (frame, row, column) defined in the 3D matrices representing the scanning path.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    

    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.getEnergySliceWeights"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getEnergySliceWeights">[docs]</a>    <span class="k">def</span> <span class="nf">getEnergySliceWeights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the frame in which is stored all the spots positions for the energy layer &#39;energy&#39;. </span>
<span class="sd">        </span>
<span class="sd">        :param energy: energy </span>
<span class="sd">        </span>
<span class="sd">        :returns: 2D numpy array containing the weights of all the spots positions. If the weight is 0, either the spot has been delivered or it was not \</span>
<span class="sd">        a spot position.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>   
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">strErr</span> <span class="o">=</span>  <span class="s">&quot;Remove spot - Energy: </span><span class="si">%f</span><span class="s"> , not in list: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>      
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">f</span><span class="p">,:,:]</span>
    
    <span class="c">###############################################################</span>
    <span class="c">#</span>
    <span class="c">#               Methods used for compensation</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c">###############################################################</span>
    
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.isPointNearOtherSpot"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.isPointNearOtherSpot">[docs]</a>    <span class="k">def</span> <span class="nf">isPointNearOtherSpot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">energy</span><span class="p">,</span><span class="n">xShift</span><span class="p">,</span> <span class="n">yShift</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Find wether a point (x,y coordinates in the IEC Gantry coordinate system) has a scan spot position in its vicinity ( +/- 1 voxel in x and y directions) in the 3D matrices representing the scanning path.</span>
<span class="sd">        </span>
<span class="sd">        :param energy: beam energy</span>
<span class="sd">        :param xShift: x spot position in mm</span>
<span class="sd">        :param yShift: y spot position in mm</span>
<span class="sd">            </span>
<span class="sd">        :returns: Wether there is a scan spot in the neighborhood of +/- 1 voxel in an energy layer. If there is no scan spot, it returns tuple([False]), otherwise it returns a tuple:</span>
<span class="sd">            </span>
<span class="sd">            * index 0: True</span>
<span class="sd">            * index 1: 3D indices of the scan spot found</span>
<span class="sd">            * index 2: (x,y) coordinates of the scan spot found</span>
<span class="sd">            * index 3: the euclidean distance between the 2 spots</span>
<span class="sd">           </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">(</span><span class="n">r</span> <span class="p">,</span><span class="n">c</span> <span class="p">)</span> <span class="o">=</span> <span class="n">coordinatesToIndex</span><span class="p">([</span><span class="n">xShift</span><span class="p">]</span> <span class="p">,</span> <span class="p">[</span><span class="n">yShift</span><span class="p">],</span>   <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span> <span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;Spot (</span><span class="si">%f</span><span class="s">,</span><span class="si">%f</span><span class="s">) -&gt; (</span><span class="si">%i</span><span class="s">,</span><span class="si">%i</span><span class="s">) is outside the plan matrix (</span><span class="si">%i</span><span class="s">,</span><span class="si">%i</span><span class="s">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">xShift</span> <span class="p">,</span> <span class="n">yShift</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">False</span><span class="p">])</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">strErr</span> <span class="o">=</span>  <span class="s">&quot;Remove spot - Energy: </span><span class="si">%s</span><span class="s"> , not in list: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">energy</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
        <span class="n">spotsInLayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="n">f</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">f</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="n">rows</span> <span class="o">=</span> <span class="n">spotsInLayer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">spotsInLayer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">listSpots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tmpSLiceEnergy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">tmpSLiceEnergy</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">print</span> <span class="s">&quot;Spacing used in scanning path (mm): </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">)</span>
        <span class="n">minDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">Inf</span>
        <span class="n">xyClosest</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">closestInd</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">ro</span><span class="p">,</span><span class="n">co</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span><span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">ro</span> <span class="p">,</span><span class="n">co</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span><span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">ro</span> <span class="p">,</span><span class="n">co</span><span class="p">]</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">euclideanDistance</span><span class="p">(</span> <span class="p">(</span><span class="n">xShift</span><span class="p">,</span> <span class="n">yShift</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>            
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">minDist</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xShift</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">yShift</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">minDist</span> <span class="o">=</span> <span class="n">dist</span>
                <span class="n">xyClosest</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
                <span class="n">closestInd</span> <span class="o">=</span> <span class="p">(</span><span class="n">ro</span> <span class="p">,</span> <span class="n">co</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">xyClosest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">closestInd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Closest spot found at : (</span><span class="si">%f</span><span class="s">,</span><span class="si">%f</span><span class="s">)(</span><span class="si">%s</span><span class="s">) w:</span><span class="si">%f</span><span class="s"> - and original spot was (</span><span class="si">%f</span><span class="s">,</span><span class="si">%f</span><span class="s">)(</span><span class="si">%s</span><span class="s">). Actual distance is:</span><span class="si">%f</span><span class="s"> &quot;</span><span class="o">%</span><span class="p">(</span><span class="n">xyClosest</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">xyClosest</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">str</span><span class="p">(</span><span class="n">closestInd</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">closestInd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">closestInd</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">xShift</span><span class="p">,</span><span class="n">yShift</span><span class="p">,</span><span class="nb">str</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">))),</span><span class="n">minDist</span><span class="p">)</span>
            <span class="n">tmpSLiceEnergy</span><span class="p">[</span><span class="n">closestInd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">closestInd</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">True</span> <span class="p">,</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">closestInd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">closestInd</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">xyClosest</span><span class="p">,</span><span class="n">minDist</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">False</span><span class="p">])</span>
 




</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.findStartingPointForMotion"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.findStartingPointForMotion">[docs]</a>    <span class="k">def</span> <span class="nf">findStartingPointForMotion</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">dispVec_IECG</span> <span class="p">,</span><span class="n">ddCurvesData</span> <span class="p">,</span><span class="n">strEnergy</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Find a starting point for the delivery of the current energy slice, i.e. find a point that could be compensated as soon as the delivery\</span>
<span class="sd">        of the current energy slice start. </span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">            **Compensation principle** :</span>
<span class="sd">            </span>
<span class="sd">                We assume the current pencil beam position being (x_cur,y_cur). This spot can be compensated\</span>
<span class="sd">                if, for a given displacement vector ( dx,dy) , there exists a scan spot position whose weight is &gt;0 in the neighborhood (+/- 1 voxel in\</span>
<span class="sd">                the 2D matrices representing a scanning path of the current energy layer) of the position \</span>
<span class="sd">                ( x_cur - dx , y_cur - dy) of the current energy layer.</span>
<span class="sd">        </span>
<span class="sd">        :param dispVec_IECG: displacement vector in the IEC gantry coordinate system in mm.</span>
<span class="sd">        :param ddCurvesData: depth dose curves data (dose profiles as a function of depth) for all the energies available. \</span>
<span class="sd">        (To be used for further implementation of 3D compensation)</span>
<span class="sd">        :param strEnergy: &#39;NewEnergy&#39; or &#39;SameEnergy&#39; depending if this is a repainting of the first painting of the energy layer. This is used to return\</span>
<span class="sd">        all the needed information to the calling function.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        :returns: None if no starting position has been found, otherwise a tuple:</span>
<span class="sd">            </span>
<span class="sd">            * index 0: spot weight</span>
<span class="sd">            * index 1: spot in the 3D matrices : frame, row, column </span>
<span class="sd">            * index 2: x position</span>
<span class="sd">            * index 3: y position</span>
<span class="sd">            * index 4: energy</span>
<span class="sd">            * index 5: list of 2 elements : spot size along x and along y </span>
<span class="sd">            * index 6: &#39;NewEnergy&#39; if the energy is changing or &#39;SameEnergy&#39; otherwise </span>
<span class="sd">            * index 7: spot type = 1 (native spot) or 2 (spot from added margin) </span>
<span class="sd">            * index 8: repainting index</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findStartPos</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Error - in findStartingPointForMotion, _idxInScanOrder should be 1 but it is </span><span class="si">%i</span><span class="s">!&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
            <span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">,</span><span class="n">dz</span><span class="p">)</span> <span class="o">=</span> <span class="n">dispVec_IECG</span> <span class="c"># in mm</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">startPos</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">r0</span><span class="p">,</span><span class="n">c0</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> 
                <span class="n">energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">]</span>
                <span class="n">xShift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">c0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span>
                <span class="n">yShift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">c0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dy</span>
                <span class="n">energyForCompens</span> <span class="o">=</span> <span class="n">energy</span>
                <span class="k">print</span> <span class="s">&quot;Ener for compens: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">energyForCompens</span><span class="p">)</span>
                <span class="n">newSpot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPointNearOtherSpot</span><span class="p">(</span><span class="n">energyForCompens</span><span class="p">,</span><span class="n">xShift</span><span class="p">,</span> <span class="n">yShift</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newSpot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">newSpot</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="n">startPos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">c0</span><span class="p">))</span>
                    <span class="k">print</span> <span class="s">&quot;Found a good starting position: </span><span class="si">%s</span><span class="s"> can be compensated by </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span> <span class="nb">str</span><span class="p">(</span><span class="n">startPos</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">newSpot</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">startPos</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">startPos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">startPos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nextIndex</span><span class="p">):</span> 
                <span class="k">print</span> <span class="s">&quot;No good starting spot found&quot;</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">flagIdxFound</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_sliceScanningOrder</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">startPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="n">startPos</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">flagIdxFound</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_idxInScanOrder</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span>
                
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flagIdxFound</span><span class="p">:</span>
                <span class="n">strErr</span> <span class="o">=</span> <span class="s">&#39;Error - no index found in _sliceScanningOrder for (</span><span class="si">%i</span><span class="s">,</span><span class="si">%i</span><span class="s">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">startPos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">startPos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
            <span class="n">dataSpot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildDataSpotToReturn</span><span class="p">(</span><span class="n">startPos</span> <span class="p">,</span> <span class="n">strEnergy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setNextSpotIndex</span><span class="p">(</span><span class="n">startPos</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dataSpot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span> 
 
</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.findCorrespondingEnergy"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.findCorrespondingEnergy">[docs]</a>    <span class="k">def</span> <span class="nf">findCorrespondingEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newEnergy</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Find in the scanning path the closest energy to newEnergy.</span>
<span class="sd">        </span>
<span class="sd">        :param newEnergy: input energy</span>
<span class="sd">        </span>
<span class="sd">        :returns: None if no energy has been found, return the found energy otherwise.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">cpyEnergies0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cpyEnergies1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">energyFound</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">e0</span> <span class="p">,</span> <span class="n">e1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cpyEnergies0</span><span class="p">,</span><span class="n">cpyEnergies1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">e0</span> <span class="o">&gt;=</span> <span class="n">newEnergy</span> <span class="o">&gt;=</span> <span class="n">e1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e0</span> <span class="o">-</span> <span class="n">newEnergy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e1</span> <span class="o">-</span> <span class="n">newEnergy</span><span class="p">):</span>
                    <span class="n">energyFound</span> <span class="o">=</span> <span class="n">e0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">energyFound</span> <span class="o">=</span> <span class="n">e1</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">energyFound</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">newEnergy</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">energyFound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">newEnergy</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">energyFound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;No energy found in scanning path corresponding to </span><span class="si">%s</span><span class="s"> MeV&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">newEnergy</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">energyFound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Energy found in scanning path: </span><span class="si">%f</span><span class="s"> m for energy: </span><span class="si">%f</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">energyFound</span><span class="p">,</span><span class="n">newEnergy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">energyFound</span>
    

    
    
    

  
    <span class="c">###############################################################</span>
    <span class="c">#</span>
    <span class="c">#               Methods used for scanning path initialization</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c">###############################################################</span>
  
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.buildScanningPath"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.buildScanningPath">[docs]</a>    <span class="k">def</span> <span class="nf">buildScanningPath</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Method that build the scanning path and creates initialize all the attributes (including the set of matrices) of this class.</span>
<span class="sd">        </span>
<span class="sd">        :param rpData: RP dicom data from pydicom</span>
<span class="sd">        :param beamIdx: Beam index (i.e. gantry angle index)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beamIdx</span> <span class="o">=</span> <span class="n">beamIdx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rpData</span> <span class="o">=</span> <span class="n">rpData</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">findBoundingBoxScanningPath</span><span class="p">(</span><span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillSpotSizeList</span><span class="p">(</span> <span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillListEnergies</span><span class="p">(</span><span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">findSpacing</span><span class="p">(</span><span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extendBoundingBox</span><span class="p">()</span>
        
        <span class="n">arrayShape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findShape3DArray</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arrayShape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_typeFloat</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialPath</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arrayShape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_typeFloat</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arrayShape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_typeFloat</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arrayShape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_typeFloat</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arrayShape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">typeIntRepaint</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arrayShape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">typeIntRepaint</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillArraysScanningPath</span><span class="p">(</span><span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialPath</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[:,:,:]</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">fillRepaintingArray</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arrayShape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int8&#39;</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extendMap</span><span class="p">(</span><span class="n">arrayShape</span><span class="p">,</span> <span class="n">updateXYAndNbRepatings</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
        
            
        
        <span class="k">print</span> <span class="s">&quot;Array spots (min MU,max MU,nb spots): </span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="p">))</span>
        <span class="k">print</span> <span class="s">&quot;Nb spots: </span><span class="si">%i</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span> <span class="s">&quot;Scanning Path ... ok&quot;</span>
        
        </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.fillArraysScanningPath"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.fillArraysScanningPath">[docs]</a>    <span class="k">def</span> <span class="nf">fillArraysScanningPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Method that fills the matrices storing X and Y coordinates and the weights from the treatment plan.</span>
<span class="sd">        </span>
<span class="sd">        :param rpData: RP dicom data from pydicom</span>
<span class="sd">        :param beamIdx: Beam index (i.e. gantry angle index)</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">beam</span> <span class="o">=</span> <span class="n">rpData</span><span class="o">.</span><span class="n">IonBeamSequence</span><span class="p">[</span><span class="n">beamIdx</span><span class="p">]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">coordinatesToIndex</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>   <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">energyLayer</span> <span class="ow">in</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isEnergyLayerEmpty</span><span class="p">(</span><span class="n">energyLayer</span><span class="p">):</span>
                    <span class="n">listX</span> <span class="o">=</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">listY</span> <span class="o">=</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
                    <span class="p">(</span><span class="n">j</span> <span class="p">,</span><span class="n">i</span> <span class="p">)</span> <span class="o">=</span> <span class="n">coordinatesToIndex</span><span class="p">(</span><span class="n">listX</span> <span class="p">,</span> <span class="n">listY</span><span class="p">,</span>   <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span> <span class="p">)</span>
<span class="c">#                     print (j ,i )</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotMetersetWeights</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">listX</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span><span class="p">[</span><span class="n">count</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">listY</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
                    
                </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.fillRepaintingArray"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.fillRepaintingArray">[docs]</a>    <span class="k">def</span> <span class="nf">fillRepaintingArray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Method that fills the matrice storing the repainting factor for each scan spot.</span>
<span class="sd">                </span>
<span class="sd">        &#39;&#39;&#39;</span>        
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="c">#             self._maxWeight = np.mean(self._arraySpots[np.where(self._arraySpots &gt; 0) ])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxWeight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">])</span>
            <span class="k">print</span> <span class="s">&quot;Isolayer repainting : max weight = </span><span class="si">%f</span><span class="s">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxWeight</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[:,:,:]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxWeight</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;max repaint factor : </span><span class="si">%i</span><span class="s">&quot;</span><span class="o">%</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> \
             <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">print</span> <span class="s">&quot;Scaled repainting - repainting factor = </span><span class="si">%i</span><span class="s">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span>
            <span class="n">indSpots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="n">indSpots</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintFactor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;in fillRepaintingArray() unknown type </span><span class="si">%s</span><span class="s"> &quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span> <span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
        
        </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.findBoundingBoxScanningPath"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.findBoundingBoxScanningPath">[docs]</a>    <span class="k">def</span> <span class="nf">findBoundingBoxScanningPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The goal of this function to find the number of energy layers, </span>
<span class="sd">        and find xmin, xmax ymin ymax of the scan spots, i.e. a bounding box</span>
<span class="sd">        </span>
<span class="sd">        :param rpData: RP dicom data from pydicom</span>
<span class="sd">        :param beamIdx: Beam index (i.e. gantry angle index)</span>

<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">rpData</span><span class="o">.</span><span class="n">IonBeamSequence</span><span class="p">[</span><span class="n">beamIdx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gantryAngle</span> <span class="o">=</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GantryAngle</span>
        <span class="n">minX</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">maxX</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">minY</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">maxY</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">energyLayer</span> <span class="ow">in</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isEnergyLayerEmpty</span><span class="p">(</span><span class="n">energyLayer</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">listX</span> <span class="o">=</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">listY</span> <span class="o">=</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">currMinX</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">listX</span><span class="p">)</span>
                <span class="n">currMaxX</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">listX</span><span class="p">)</span>
                <span class="n">currMinY</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">listY</span><span class="p">)</span>
                <span class="n">currMaxY</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">listY</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">currMinX</span> <span class="o">&lt;</span> <span class="n">minX</span><span class="p">:</span>
                    <span class="n">minX</span> <span class="o">=</span> <span class="n">currMinX</span>
                <span class="k">if</span> <span class="n">currMaxX</span> <span class="o">&gt;</span> <span class="n">maxX</span><span class="p">:</span>
                    <span class="n">maxX</span> <span class="o">=</span> <span class="n">currMaxX</span>
                <span class="k">if</span> <span class="n">currMinY</span> <span class="o">&lt;</span> <span class="n">minY</span><span class="p">:</span>
                    <span class="n">minY</span> <span class="o">=</span> <span class="n">currMinY</span>
                <span class="k">if</span> <span class="n">currMaxY</span> <span class="o">&gt;</span> <span class="n">maxY</span><span class="p">:</span>
                    <span class="n">maxY</span> <span class="o">=</span> <span class="n">currMaxY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span> <span class="o">=</span> <span class="n">count</span>
        <span class="c">#print &quot;Bounding box: xmin:%f , xmax:%f , ymin: %f , ymax: %f&quot;%(minX,maxX,minY,maxY)                    </span>
        <span class="k">print</span> <span class="s">&quot;Nb energy layers: </span><span class="si">%i</span><span class="s">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span> <span class="o">=</span> <span class="p">[(</span> <span class="n">minX</span><span class="o">-</span><span class="mf">0.01</span><span class="p">,</span><span class="n">minY</span><span class="o">-</span><span class="mf">0.01</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span> <span class="n">maxX</span><span class="o">+</span><span class="mf">0.01</span><span class="p">,</span><span class="n">maxY</span><span class="o">+</span><span class="mf">0.01</span><span class="p">)]</span> 
</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.extendBoundingBox"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.extendBoundingBox">[docs]</a>    <span class="k">def</span> <span class="nf">extendBoundingBox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This method extends the bounding box of the initial scanning path if &#39;AddMapMargins&#39; (in dictSettings) is True. \</span>
<span class="sd">        If &#39;MarginParams&#39; = [dx,dy,dz], it is extended of dx at the left and the right and dy at\</span>
<span class="sd">        the top and bottom of the initial bounding box</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="p">[(</span> <span class="n">minX</span><span class="p">,</span><span class="n">minY</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span> <span class="n">maxX</span><span class="p">,</span><span class="n">maxY</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span>  
        <span class="p">[</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">,</span><span class="n">dz</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marginParams</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span> <span class="o">=</span> <span class="p">[(</span> <span class="n">minX</span><span class="o">-</span><span class="n">dx</span><span class="p">,</span><span class="n">minY</span><span class="o">-</span><span class="n">dy</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span> <span class="n">maxX</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span><span class="n">maxY</span><span class="o">+</span><span class="n">dy</span><span class="p">)]</span>

</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.fillSpotSizeList"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.fillSpotSizeList">[docs]</a>    <span class="k">def</span> <span class="nf">fillSpotSizeList</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This function fills the list of spot sizes (attribute of the class).</span>
<span class="sd">        </span>
<span class="sd">        :param rpData: RP dicom data from pydicom</span>
<span class="sd">        :param beamIdx: Beam index (i.e. gantry angle index)</span>
<span class="sd">      </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">rpData</span><span class="o">.</span><span class="n">IonBeamSequence</span><span class="p">[</span><span class="n">beamIdx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listSpotSize</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">energyLayer</span> <span class="ow">in</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isEnergyLayerEmpty</span><span class="p">(</span><span class="n">energyLayer</span><span class="p">):</span>
                <span class="c">#sig = FWHM / (2 * sqrt( 2 * ln 2)) ~ FWHM / 2.3548200 </span>
                <span class="c">#self._listSpotSize.append([value/2.3548200 for value in energyLayer.ScanningSpotSize])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_listSpotSize</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanningSpotSize</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.fillListEnergies"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.fillListEnergies">[docs]</a>    <span class="k">def</span> <span class="nf">fillListEnergies</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This function fills the list of energies (attribute of the class).</span>
<span class="sd">        </span>
<span class="sd">        :param rpData: RP dicom data from pydicom</span>
<span class="sd">        :param beamIdx: Beam index (i.e. gantry angle index)</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">rpData</span><span class="o">.</span><span class="n">IonBeamSequence</span><span class="p">[</span><span class="n">beamIdx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">energyLayer</span> <span class="ow">in</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isEnergyLayerEmpty</span><span class="p">(</span><span class="n">energyLayer</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energyLayer</span><span class="o">.</span><span class="n">NominalBeamEnergy</span><span class="p">)</span>
        
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.getListEnergies"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getListEnergies">[docs]</a>    <span class="k">def</span> <span class="nf">getListEnergies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the list of energies used in the scanning path.</span>
<span class="sd">  </span>
<span class="sd">        &#39;&#39;&#39;</span>        
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span>
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.findSpacing"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.findSpacing">[docs]</a>    <span class="k">def</span> <span class="nf">findSpacing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rpData</span><span class="p">,</span> <span class="n">beamIdx</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This function finds the spacing to use to represent the scanning path spatially in a 3D matrix. The spacing is the smallest y (resp. x) difference between\</span>
<span class="sd">        two consecutive scan spots.</span>
<span class="sd">        </span>
<span class="sd">        :param rpData: RP dicom data from pydicom</span>
<span class="sd">        :param beamIdx: Beam index (i.e. gantry angle index)</span>

<span class="sd">        &#39;&#39;&#39;</span>    
    
    
        <span class="n">minX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="n">minY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">rpData</span><span class="o">.</span><span class="n">IonBeamSequence</span><span class="p">[</span><span class="n">beamIdx</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">energyLayer</span> <span class="ow">in</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isEnergyLayerEmpty</span><span class="p">(</span><span class="n">energyLayer</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c">#Only 1 spot in the energy layer</span>
                        <span class="k">continue</span>
                    
                    <span class="n">argMinX</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">argMinY</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">listX</span> <span class="o">=</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="c">#X Position in mm in the IEC Gantry coordinate system</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listX</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listX</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">diffX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span> <span class="p">)</span>
                    <span class="n">currMinx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diffX</span> <span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">currMinx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">argMinX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">diffX</span><span class="p">)</span><span class="c"># Used to know if diffX = 0 somewhere</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                            <span class="n">currMinx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diffX</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">currMinx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># really small value greater than 0 -&gt; avoid to divide by zero when spacing = 0</span>
                    <span class="k">if</span> <span class="n">currMinx</span> <span class="o">&lt;</span> <span class="n">minX</span> <span class="ow">and</span> <span class="n">currMinx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">minX</span> <span class="o">=</span> <span class="n">currMinx</span>
                    
                    
                    
                    <span class="n">listY</span> <span class="o">=</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="c">#Y Position in mm in the IEC Gantry coordinate system</span>
                    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listY</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listY</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">diffY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span> <span class="p">)</span>
                    <span class="n">currMiny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span> <span class="n">diffY</span> <span class="p">)</span> 
        
                    <span class="k">if</span> <span class="n">currMiny</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">argMinY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">diffY</span><span class="p">)</span><span class="c"># Used to know if diffY = 0 somewhere</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffY</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                            <span class="n">currMiny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diffY</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">currMiny</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># really small value greater than 0 -&gt; avoid to divide by zero when spacing = 0</span>
                        
                    <span class="k">if</span> <span class="n">currMiny</span> <span class="o">&lt;</span> <span class="n">minY</span> <span class="ow">and</span> <span class="n">currMiny</span> <span class="o">&gt;</span>  <span class="mi">0</span><span class="p">:</span>
                        <span class="n">minY</span> <span class="o">=</span> <span class="n">currMiny</span>
                    
                        
                    <span class="k">if</span> <span class="n">argMinX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">diffY</span><span class="p">[</span><span class="n">argMinX</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;2 Spots have same X and Y in the plan&quot;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">argMinY</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">diffX</span><span class="p">[</span><span class="n">argMinY</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;2 Spots have same X and Y in the plan&quot;</span><span class="p">)</span>
                        
                            
                    
        <span class="k">if</span> <span class="n">minX</span> <span class="o">==</span>   <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="n">minX</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">minY</span> <span class="o">==</span>   <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="n">minY</span> <span class="o">=</span> <span class="mi">1</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span> <span class="o">=</span> <span class="p">[</span><span class="n">minX</span> <span class="p">,</span> <span class="n">minY</span><span class="p">]</span>
        <span class="k">print</span> <span class="s">&quot;Spacing scanning path (mm): </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">)</span>
        
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.findShape3DArray"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.findShape3DArray">[docs]</a>    <span class="k">def</span> <span class="nf">findShape3DArray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Function that finds the shape of the 3D matrices that are created to represent the scanning path.\</span>
<span class="sd">        It is based on the number of energy layers, the spacing and the bounding box.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nbFrames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span>
            <span class="n">maxAbsY</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="p">])</span>
            <span class="n">maxAbsX</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">])</span>
            <span class="n">nbRows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span> <span class="n">maxAbsY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">nbCols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span> <span class="n">maxAbsX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map3DMargin</span><span class="p">:</span>
                <span class="c">#Using PSTAR ranges in water for energies 30MeV to 250MeV, the average change of range is 1e-1 g.cm-2 per MeV which correspond to 1mm/MeV in water</span>
                <span class="n">deltaRange</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># mm/MeV</span>
                <span class="c">#self._listEnergies should be ordered in decreasing order</span>
                <span class="n">deltaEnergy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span>
                <span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_marginParams</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">dFrames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span> <span class="n">dz</span> <span class="o">/</span> <span class="p">(</span><span class="n">deltaRange</span> <span class="o">*</span> <span class="n">deltaEnergy</span><span class="p">)</span> <span class="p">))</span>
                <span class="n">nbFrames</span> <span class="o">=</span> <span class="n">nbFrames</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dFrames</span>
                <span class="n">firstEner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">lastEner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dFrames</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">firstEner</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">deltaEnergy</span> <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lastEner</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">deltaEnergy</span> <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">)</span> <span class="o">==</span> <span class="n">nbFrames</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span> <span class="o">=</span> <span class="n">nbFrames</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Wrong number of frame when trying 3D margin in plan. nb layers = </span><span class="si">%i</span><span class="s"> , nbFrames = </span><span class="si">%i</span><span class="s"> , originally </span><span class="si">%i</span><span class="s"> layers&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">)</span> <span class="p">,</span> <span class="n">nbFrames</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
                
            <span class="c">#self._spacing = [minSpacingX , minSpacingY]</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbFrames</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nbRows</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nbCols</span><span class="p">))</span>
            <span class="k">print</span> <span class="s">&quot;Shape array scanning path : </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;in find 3D shape: </span><span class="se">\n</span><span class="s">self._nbEnergyLayers : </span><span class="si">%s</span><span class="s"> </span><span class="se">\n</span><span class="s">self._boundingBox : </span><span class="si">%s</span><span class="s"> </span><span class="se">\n</span><span class="s">self._listSpotSize: </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbEnergyLayers</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundingBox</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_listSpotSize</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span> <span class="p">(</span><span class="s">&quot;in find 3D shape: self._nbEnergyLayers is None or self._boundingBox is None or self._listSpotSize is None&quot;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.extendMap"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.extendMap">[docs]</a>    <span class="k">def</span> <span class="nf">extendMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span> <span class="n">updateXYAndNbRepatings</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Extend scan spot position maps in the case of margins added.</span>
<span class="sd">        </span>
<span class="sd">        :param shape: tuple (number of frames, number of rows, number of columns). Shape of the 3D matrices.</span>
<span class="sd">        :param updateXYAndNbRepatings: True / False to update the 3D matrices stroring X and Y coordinates and the number of repaintings.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillSpotTypeArray</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">updateXYAndNbRepatings</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">updateXYArrayForMargin</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">updateNbRepaintingsForMargins</span><span class="p">()</span>
     
</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.fillSpotTypeArray"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.fillSpotTypeArray">[docs]</a>    <span class="k">def</span> <span class="nf">fillSpotTypeArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Fill the 3D array of spot types:</span>
<span class="sd">            </span>
<span class="sd">            * typeOutside = 0</span>
<span class="sd">            * typeOrigin = 1</span>
<span class="sd">            * typeAdded = 2</span>
<span class="sd">            </span>
<span class="sd">        :param shape: tuple (number of frames, number of rows, number of columns). Shape of the 3D matrix.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">maskInitialMap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int8&#39;</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">indMap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">maskInitialMap</span><span class="p">[</span><span class="n">indMap</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">[</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">,</span><span class="n">dz</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_marginParams</span>
        <span class="n">nbIterations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)]))</span>
        <span class="n">dilatedMap</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">maskInitialMap</span><span class="p">,</span><span class="n">iterations</span> <span class="o">=</span> <span class="n">nbIterations</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int8&#39;</span><span class="p">)</span>
        <span class="n">indAddedSpot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="n">maskInitialMap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">dilatedMap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="n">indMap</span><span class="p">]</span> <span class="o">=</span> <span class="n">typeOrigin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="n">indAddedSpot</span><span class="p">]</span> <span class="o">=</span> <span class="n">typeAdded</span>
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.updateXYArrayForMargin"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.updateXYArrayForMargin">[docs]</a>    <span class="k">def</span> <span class="nf">updateXYArrayForMargin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">shape</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Update X, Y 3D matrices for margins added.</span>
<span class="sd">        </span>
<span class="sd">        :param shape: tuple (number of frames, number of rows, number of columns). Shape of the 3D matrix.</span>

<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">indAddedSpots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span> <span class="o">==</span> <span class="n">typeAdded</span><span class="p">)</span>
        <span class="p">(</span><span class="n">listX</span><span class="p">,</span><span class="n">listY</span><span class="p">)</span> <span class="o">=</span> <span class="n">indexToCoordinates</span><span class="p">(</span> <span class="n">indAddedSpots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span> <span class="n">indAddedSpots</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span><span class="p">[</span><span class="n">indAddedSpots</span><span class="p">]</span> <span class="o">=</span> <span class="n">listX</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span><span class="p">[</span><span class="n">indAddedSpots</span><span class="p">]</span> <span class="o">=</span> <span class="n">listY</span>
        </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.updateNbRepaintingsForMargins"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.updateNbRepaintingsForMargins">[docs]</a>    <span class="k">def</span> <span class="nf">updateNbRepaintingsForMargins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Update 3D matrix storing the number of repaintings. To be used if margins are added.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>    
        <span class="n">indAddedSpots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span> <span class="o">==</span> <span class="n">typeAdded</span><span class="p">)</span>
        <span class="n">maxRepaint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="n">indAddedSpots</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxRepaint</span>
        

</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.buildDataSpotToReturn"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.buildDataSpotToReturn">[docs]</a>    <span class="k">def</span> <span class="nf">buildDataSpotToReturn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span> <span class="p">,</span> <span class="n">strEnergy</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Build the spot data to return for &quot;regular&quot; delivery.</span>
<span class="sd">        It should return a tuple with:</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Inputs:</span>
<span class="sd">        ind: spot indices</span>
<span class="sd">        strEnergy: string saying if the is a new energy or not</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">ener</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listSpotSize</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
            <span class="n">typeSpot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">typeSpot</span> <span class="o">=</span> <span class="n">typeOrigin</span>
        <span class="n">repaintFactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_repaintingIndex&#39;</span> <span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">repaintIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">repaintIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">repaintFactor</span> <span class="o">&gt;</span>  <span class="mi">1</span> <span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxWeight</span> <span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">ener</span><span class="p">,</span><span class="n">size</span> <span class="p">,</span><span class="n">strEnergy</span><span class="p">,</span><span class="n">typeSpot</span><span class="p">,</span><span class="n">repaintIndex</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">return</span><span class="p">(</span> <span class="n">weight</span> <span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">ener</span><span class="p">,</span><span class="n">size</span> <span class="p">,</span><span class="n">strEnergy</span><span class="p">,</span><span class="n">typeSpot</span><span class="p">,</span><span class="n">repaintIndex</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">repaintFactor</span> <span class="o">&gt;=</span>  <span class="mi">1</span> <span class="p">:</span>
                <span class="k">return</span><span class="p">(</span> <span class="n">weight</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">repaintFactor</span><span class="p">)</span> <span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">ener</span><span class="p">,</span><span class="n">size</span> <span class="p">,</span><span class="n">strEnergy</span><span class="p">,</span><span class="n">typeSpot</span><span class="p">,</span><span class="n">repaintIndex</span><span class="p">)</span>
            <span class="c">#else:</span>
                <span class="c">#yield( 0 , ind, x,y,ener,size ,strEnergy)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span> <span class="o">==</span> <span class="n">repaintingMethodSlice</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">return</span><span class="p">(</span> <span class="n">weight</span> <span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">ener</span><span class="p">,</span><span class="n">size</span> <span class="p">,</span><span class="n">strEnergy</span><span class="p">,</span><span class="n">typeSpot</span><span class="p">,</span><span class="n">repaintIndex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strErr</span> <span class="o">=</span> <span class="s">&quot;Repainting method is set to </span><span class="si">%s</span><span class="s">. It should be Isolayer or Scaled or full weight&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repaintingMethodSlice</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">strErr</span><span class="p">)</span>
        
        </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.getSliceOrderFromPlan"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getSliceOrderFromPlan">[docs]</a>    <span class="k">def</span> <span class="nf">getSliceOrderFromPlan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the regular scanning order (order provided in the dicom file) for the current energy slice.</span>
<span class="sd">        </span>
<span class="sd">        :returns: tuple of 2 numpy arrays containing respectively the row index and the column index of each spot.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rpData</span><span class="o">.</span><span class="n">IonBeamSequence</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_beamIdx</span><span class="p">]</span>
        <span class="n">ind_rows_cols</span> <span class="o">=</span> <span class="p">[[],[]]</span>
        <span class="k">for</span> <span class="n">energyLayer</span> <span class="ow">in</span> <span class="n">beam</span><span class="o">.</span><span class="n">IonControlPointSequence</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isEnergyLayerEmpty</span><span class="p">(</span><span class="n">energyLayer</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">NominalBeamEnergy</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listEnergies</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">]:</span> 
                    <span class="n">listX</span> <span class="o">=</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">listY</span> <span class="o">=</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotPositionMap</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">listX</span><span class="p">,</span><span class="n">listY</span><span class="p">):</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayY</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> \
                                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrayNumberOfRepainting</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \
                                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="c">#                             print ind</span>
                            <span class="n">ind_rows_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">ind_rows_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_rows_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ind_rows_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>

    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.getNumberOfRepaintingsPerSlice"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getNumberOfRepaintingsPerSlice">[docs]</a>    <span class="k">def</span> <span class="nf">getNumberOfRepaintingsPerSlice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the number of time each energy slice hase been repaint</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repaintingIndex</span> <span class="o">+</span> <span class="mi">1</span>
        
    

    <span class="c">###############################################################</span>
    <span class="c">#</span>
    <span class="c">#               Methods used for visualization</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c">###############################################################</span>
</div>
<div class="viewcode-block" id="ScanningPathSingleBeam.locateSpots"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.locateSpots">[docs]</a>    <span class="k">def</span> <span class="nf">locateSpots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">listCoord</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create a 2D array where spots defined in listCoord are set to a non-null value. \</span>
<span class="sd">        This method is used to visually locate spots by displaying the array afterwards.</span>

<span class="sd">        :param listInd: list of coordinates of spots to display</span>
<span class="sd">        :param listCoord: list of [x,y] coordinates of the spots of interest.</span>

<span class="sd">        :returns: A 2D numpy array where value = 0 if this is not a spot of interest and  1&gt;= value  &gt;= 0.5 otherwise.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpots</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">tmpSLiceEnergy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">nbSpots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">listCoord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nbSpots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">listCoord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">listCoord</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
            
            <span class="p">(</span><span class="n">r</span> <span class="p">,</span><span class="n">c</span> <span class="p">)</span> <span class="o">=</span> <span class="n">coordinatesToIndex</span><span class="p">([</span><span class="n">x</span><span class="p">]</span> <span class="p">,</span> <span class="p">[</span><span class="n">y</span><span class="p">],</span>   <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_spacing</span> <span class="p">)</span>
            <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;Locate spots: </span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> , </span><span class="si">%i</span><span class="s"> </span><span class="si">%i</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
            <span class="n">tmpSLiceEnergy</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">/</span><span class="n">nbSpots</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">tmpSLiceEnergy</span>
    
    </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.getMapWithEnhancedSpot"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getMapWithEnhancedSpot">[docs]</a>    <span class="k">def</span> <span class="nf">getMapWithEnhancedSpot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create a 2D array representing all the spot position of a energy layer where a given spot, defined by its 3D indices \</span>
<span class="sd">        in  the matrices representing the scanning path, is &quot;highlighted&quot;. \</span>
<span class="sd">        This method is used to visually locate a spot by displaying the array afterwards.</span>

<span class="sd">        :param ind: indices (frame,row,column) of the spot of interest.</span>
<span class="sd">        </span>

<span class="sd">        :returns: A 2D numpy array where value = 0 if this is not a spot positions, value = 1 if this is a spot position in the energy layer and value = 2\</span>
<span class="sd">        for the spot of interest.</span>

<span class="sd">        &#39;&#39;&#39;</span>        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
            <span class="n">indSpots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],:,:]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s">&#39;int8&#39;</span><span class="p">,</span><span class="n">order</span> <span class="o">=</span> <span class="s">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">array</span><span class="p">[</span><span class="n">indSpots</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">array</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indSpots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_initialPath</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_initialPath</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],:,:]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="s">&#39;int8&#39;</span><span class="p">,</span><span class="n">order</span> <span class="o">=</span> <span class="s">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">array</span><span class="p">[</span><span class="n">indSpots</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">array</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">array</span>     
            </div>
<div class="viewcode-block" id="ScanningPathSingleBeam.getMapWithMargin"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.ScanningPathSingleBeam.getMapWithMargin">[docs]</a>    <span class="k">def</span> <span class="nf">getMapWithMargin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create a 2D array representing the positions added to the original scan spot position (margins added) and the original positions.\</span>
<span class="sd">        This method is used to visually locate the different regions.</span>
<span class="sd">        </span>
<span class="sd">        :returns: A 2D numpy array with 3 different areas depending on the spot types.</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_addMapMargins</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scanPath</span> <span class="o">!=</span> <span class="n">scanningPath</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arraySpotType</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_currEnergySlice</span><span class="p">,:,:]</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="c">###############################################################</span>
<span class="c">#</span>
<span class="c">#              Utilities</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">###############################################################</span>

</div></div>
<div class="viewcode-block" id="euclideanDistance"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.euclideanDistance">[docs]</a><span class="k">def</span> <span class="nf">euclideanDistance</span><span class="p">(</span> <span class="n">xy1</span> <span class="p">,</span> <span class="n">xy2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Computes the Euclidean distance between 2 points: </span>
<span class="sd">    :param xy1: (x1, y1) </span>
<span class="sd">    :param xy2: (x2,y2)</span>
<span class="sd">    </span>
<span class="sd">    :returns: Euclidean distance</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xy1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xy2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span> <span class="p">(</span><span class="n">xy1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xy2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">xy1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xy2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span> <span class="p">(</span><span class="n">xy1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xy2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">dist</span>
</div>
<div class="viewcode-block" id="isEnergyLayerEmpty"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.isEnergyLayerEmpty">[docs]</a><span class="k">def</span> <span class="nf">isEnergyLayerEmpty</span><span class="p">(</span><span class="n">energyLayer</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Check wether an energy layer in the dicom file is empty.</span>
<span class="sd">    </span>
<span class="sd">    :returns: True if empty, False otherwise.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotMetersetWeights</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotMetersetWeights</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotMetersetWeights</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">energyLayer</span><span class="o">.</span><span class="n">ScanSpotMetersetWeights</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>


</div>
<div class="viewcode-block" id="coordinatesToIndex"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.coordinatesToIndex">[docs]</a><span class="k">def</span> <span class="nf">coordinatesToIndex</span><span class="p">(</span> <span class="n">listX</span> <span class="p">,</span> <span class="n">listY</span> <span class="p">,</span> <span class="n">nRows</span><span class="p">,</span> <span class="n">nCols</span><span class="p">,</span> <span class="n">spacing</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Find indices in 2D.\</span>
<span class="sd">    For a given list of X coordinates, return the column index for each of them and for a given list of Y coordinates, return the row index for each of them.</span>
<span class="sd">    </span>
<span class="sd">    :param listX: list of x coordinates</span>
<span class="sd">    :param listX: list of y coordinates</span>
<span class="sd">    :param nRows: number of rows in a 2D matrix</span>
<span class="sd">    :param nCols: number of columns in a 2D matrix</span>
<span class="sd">    :param spacing: list :[xSpacing, y spacing]</span>
<span class="sd">    </span>
<span class="sd">    Computes lhe list of column indices and the list or rows indices. (x = 0 , y = 0) as being (f = (NumberOfFrames - 1)/2, r = (NumberOfRows - 1)/2, c = (NumberOfCols - 1)/2)</span>
<span class="sd">    </span>
<span class="sd">    :returns: (round_j  , round_i ), where i are columns and j rows. X is associated to columns and y to rows.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
   
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listX</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listY</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span> <span class="n">x</span> <span class="o">/</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nCols</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> 
    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span> <span class="n">y</span> <span class="o">/</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nRows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    
    <span class="n">round_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="s">&#39;int16&#39;</span><span class="p">)</span>
    <span class="n">round_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="s">&#39;int16&#39;</span><span class="p">)</span>
    
        
    <span class="k">return</span> <span class="p">(</span> <span class="n">round_j</span><span class="p">,</span>  <span class="n">round_i</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="indexToCoordinates"><a class="viewcode-back" href="../../../mspt.dicomReader.html#mspt.dicomReader.scanningPath.indexToCoordinates">[docs]</a><span class="k">def</span> <span class="nf">indexToCoordinates</span><span class="p">(</span> <span class="n">listRow</span> <span class="p">,</span> <span class="n">listCols</span> <span class="p">,</span> <span class="n">nRows</span><span class="p">,</span> <span class="n">nCols</span><span class="p">,</span> <span class="n">spacing</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Find coordinates in 2D.\</span>
<span class="sd">    For a given list of Row indices, return the x coord for each of them and \</span>
<span class="sd">    for a given list of Column indices, return the y coord for each of them.</span>
<span class="sd">    </span>
<span class="sd">    :param listRow: list of rows indices</span>
<span class="sd">    :param listCols: list of columns indices</span>
<span class="sd">    :param nRows: number of rows in a 2D matrix</span>
<span class="sd">    :param nCols: number of columns in a 2D matrix</span>
<span class="sd">    :param spacing: list :[xSpacing, y spacing]</span>

<span class="sd">    </span>
<span class="sd">    :returns: The list of x coords and the list of y coords. </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>    
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listRow</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">listCols</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span> <span class="n">c</span> <span class="o">-</span> <span class="p">((</span><span class="n">nCols</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span> <span class="n">r</span> <span class="o">-</span> <span class="p">((</span><span class="n">nRows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>     

    
    <span class="k">return</span> <span class="p">(</span> <span class="n">x</span><span class="p">,</span>  <span class="n">y</span><span class="p">)</span>
</pre></div></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Paul Morel, LIGM, Univ. Paris-Est MLV, France.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>